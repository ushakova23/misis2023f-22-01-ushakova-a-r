<h2>Лабораторная работа №3</h2>

1. Добавлена функция

```
cv::Mat autocontrast(const cv::Mat& img, const double q_black, const double q_white)
```

которая возвращает более контрастное изображение. Серьёзность контраста зависит от белого и чёрного квантилей (числа от 0 до 1), которые говорят нам, какую долю пикселей преобразовывать в белый или чёрный цвета. Принцип работы таков:

* На основе гистограммы формируем функция распределения яркости ```CDF(x) = Prob{X <= x}```, вероятность считается как частное числа пикселей i-й интенсивности к их общему количеству.
* Вычисляем пороги белого и чёрного ```wT``` и ```bT```: если интенсивность пикселя будет меньше ```bT```, то он считается чёрным, если она больше ```wT```, то он считается белым.
* Наконец, проходимся двойным циклом по всем пикселям. Здесь я выделил два метода преобразования интенсивности: **Naive** (просто сравнивать) и **Linear** (линейно изменять). Рассмотрим их более подробно.

2. Naive метод. Сравнение выглядит примерно так:

```
if (pixel <= bT) {
	res.at<uchar>(i, j) = 0;
}
else if (pixel >= wT) {
	res.at<uchar>(i, j) = 255;
}
```

Результат применения (берутся небольшие квантили, 1% и 0.5% для чёрного и белого цветов):

![Наивная Лена](prj.lab/test/lab03/lena/naive.png)

На перьях шляпки и на плече хорошо видно, что мы получаем точечное контрастирование. Разумеется, гистограмма выглядит как столбики белого / чёрного / интенсивностей, вошедших в интервал ```(bT, wT)```, остальные оказываются нулевыми. Чтобы убрать такую "поточечность", будем изменять интенсивность линейно.

3. Linear метод. Выведена следующая формула:

```
max(0, min(255, 255 / | wT - bT | * (pixel - bT) ) )
```

Несложно убедиться, что есть интенсивность ```pixel < bT``` или ```pixel > wT```, то он становится чёрным или белым соответственно. Однако чем она ближе к порогу, тем сильнее меняется: за счёт этой функциональной зависимости мы получаем, во-первых, более гладкий и, во-вторых, охватывающий почти все области, контраст:

![Линейная Лена](prj.lab/test/lab03/lena/linear.png)

Гистограмма стала более разреженной (соседние интенсивности склеиваются в одну), а числа пикселей каждой интенсивности выровнялись - последствия линейности преобразования.

4. Проверка: если задать квантили ```black_q = white_q = 0.5```, то мы сделаем изображение чёрно-белым:

![Чёрно-белая Лена](prj.lab/test/lab03/lena/q05.png)

Порогами чёрного и белого будут средние интенсивности 128 и 129: так что чуть более тёмные места станут чёрными, а чуть более светлые - белыми. Что может быть ещё контрастнее?

5. Результат применения на двух типах картинок (было/стало):

![Старое фото (было)](prj.lab/test/lab03/grayscale.png)

6. Добавлена функция наивного контрастирования

```
cv::Mat autocontrast_naive(const cv::Mat& img, const double q_black, const double q_white)
```

Когда ей подают на вход трёхканальное RGB изображение, она применяет ```autocontrast()``` по каждому каналу. Протестируем её работу (было/стало):

![Наивный young](prj.lab/test/lab03/naive.png)

Из последнего изображения видно, что наивное контрастирование работает довольно плохо.

Гистограммы: наивный, ненаивный контрасты (все каналы учитываются, так как переводим в HSV и смотрим на канал интенсивности, для каждого пикселя меняем значение и записываем его в loopback table, которую потом применяем к данному каналу) и контраст с использованием алгоритма AGCIE (умная гамма-коррекция по каналу интенсивности в HSV формате, опять же):

![AGCIE red](prj.lab/test/lab03/red.jpg)
