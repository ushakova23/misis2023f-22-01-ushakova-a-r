<h2>Лабораторная работа №2</h2>

1. Добавлены и реализованы функции

```
cv::Mat gen_tgtimg00(const int lev0, const int lev1, const int lev2)
```

```
cv::Mat add_noise_gau(const cv::Mat& img, const int std)
```

```
cv::Mat add_noise_salt(const cv::Mat& img, const int pa, const int pb)
```

```
cv::Mat calcHistNaive(const cv::Mat& src);
```

```
cv::Mat calcHistLib(const cv::Mat& src);
```

```
cv::Mat drawHist(const cv::Mat& counter, const int height = 256, const int bold = 1);
```

Рассмотрим более подробно как вычисляется и рисуется гистограмма:

* Функция ```calcHistNaive``` просто перебирает все пиксели ```src``` матрицы, передавая массив ```counter``` длины 256 (каждый элемент которого представляет количество пикселей определённого цвета) в ```drawHist```

* А затем функция ```drawHist``` формирует изображение гистограммы, отрисовывая для каждого цвета прямоугольник с высотой, равной его значению, и шириной ```bold```. А затем подписывает гистограмму, обозначая общее количество пикселей (```src.cols``` x ```src.rows```) и глубину исходного изображения.

* Функция ```calcHistLib``` вместо двойного цикла использует функцию из библиотеки ```opencv``` ```calcHist``` (однако затем массиву с подсчитанными пикселями будет требоваться нормализация)

2. Для демонстрации работы двух разных функций зашумления мы будем использовать фотокарточку Лены; её гистограмма представлена ниже:

![Подопытная Лена](prj.lab/test/lab02/lena.png)

Функция ```add_noise_salt``` реализует **Salt&Pepper Noise**. Она принимает нижний и верхний пороги зашумлённых пикселей, а затем случайно генерирует их число и позиции. Salt означает количество белых, а Pepper - чёрных пикселей. Это самый простой из возможных шумов, так что результат его работы выглядит не очень впечатляюще:

![Лена, зашумлённая by Salt&Pepper](prj.lab/test/lab02/salt-pepper.png)

В гистограмме зашумлённого изображения самыми высокими оказываются столбики белого и чёрного цвета, прочие немного понизились - такой результат следует напрямую из реализации.

3. Функция ```add_noise_gau``` реализует **Gauss Noise**. С помощью ```cv::randn``` она генерирует матрицу с нормально распределёнными случайными числами. Их матожидание, ```mean```, мы берём нулевым, чтобы среднее значение зашумлённого изображения не отличалось от исходного. С ненулевой медианой основные цветовые столбцы гистограммы будут сдвинуты, а распределения будут больше похожи на нормальные:

![Изображение с mean = 100 и увеличивающимся std](prj.lab/test/lab02/mean-std.png)

В ```cv::randn``` среднеквадратичное отклонение ```std``` даёт нам отклонение от матожидания. Чем больше будет ```std``` (берутся более нижние строчки), тем сильнее столбики будут "расползаться", так как вероятность появления новых цветов будет выше.

В итоге попиксельно складываем случайную матрицу и наше изображение (первая должна иметь тип ```CV_16SC1```; если взять ```unsigned char```, то распределение не будет нормальным, так как не будет значений слева от матожидания). Получаем зашумлённую картинку:

![Лена, зашумлённая by Gauss](prj.lab/test/lab02/gauss.png)

Гистограмма зашумлённого изображения напоминает нормальную кривую (мы взяли ```std=20```)

4. Расчёт статистик случайных гауссовых масок с помощью python скрипта: использовались статистический тест Шапиро (библиотека scipy) и рисование QQ-графиков (библиотека matplotlib). Один из QQ-графиков (```mean = 127```, ```std = 11, 31```) показывает, что случайные числа в матрице и правда распределены нормально (мало отклоняются от диагонали):

![QQ-графики](prj.lab/test/lab02/stats/qq-plots.png)

Кроме того, можно посмотреть на гистограммы (для тех же двух случайных масок) и увидеть, что они очень похожи на нормальную кривую **bell-shaped**:

![Гистограммы](prj.lab/test/lab02/stats/hists.png)

Таблица с отклонениями матожидания и среднеквадратичного отклонения от теоретических параметров:

| MEAN | STD |
| ---- | --- |
| 0.00112915039062 | 0.041584671240483 |
| 0.04339599609375 | 0.01689416848298 |
| 0.03549194300000 | 0.095582763889897 |
| 0.05899047851562 | 0.093146866895527 |
| 0.26417541500000 | 0.8368595594616 |

5. Консольное приложение task02.exe генерирует коллаж тестовых изображений с разными яркостями:

![Тестовый коллаж](prj.lab/test/lab02/etalon.jpg)

Затем с помощью гауссова шума зашумляет его с разными std, равными 3, 7, 15:

![Зашумлённый тестовый коллаж](prj.lab/test/lab02/noised.png)

На коллаже из гистограмм для каждой картинки хорошо видно, что вначале у нас было всего три цвета (первая строчка), причём яркость для каждого следующего изображения становилась менее контрастной (сдвигалась к центру, то есть к серому); поскольку ```mean=0```, то столбики никуда не сдвигаются по вертикали (большинство пикселей сохраняют свой цвет, так как к ним скорее всего будет прибавлено 0 интенсивности); поскольку ```std``` растёт, то появляются новые столбики (разброс доп. интенсивности становится больше)

Столбики, соответствующие белому и чёрному цветам, на изображениях в первом столбце довольно высокие, поскольку ```uchar``` ограничен значениями 0 и 255: если мы выходим за пределелы, то пиксели из "хвостов" этих кривых становятся белыми/чёрными.

![Итоговая гистограмма](prj.lab/test/lab02/res-hist-true.png)